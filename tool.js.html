<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: tool.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: tool.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>"use strict";

/*
 * Copyright (C) 2017-2022 UBports Foundation &lt;info@ubports.com>
 * Copyright (C) 2017-2022 Johannah Sprinz &lt;hannah@ubports.com>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see &lt;http://www.gnu.org/licenses/>.
 */

import child_process from "child_process";
import { getAndroidToolPath, getAndroidToolBaseDir } from "android-tools-bin";
import EventEmitter from "events";
import { removeFalsy } from "./common.js";
import { CancelablePromise } from "./cancelable-promise.js";

/**
 * generic tool class
 * @property {String} tool tool identifier
 * @property {String} executable tool executable path
 * @property {Array&lt;String>} extra extra cli arguments
 * @property {Object} execOptions options for child_process.exec
 */
export class Tool extends EventEmitter {
  constructor(options = {}) {
    super();
    this.tool = options?.tool;
    this.executable = getAndroidToolPath(options?.tool);
    this.extra = options?.extra || [];
    this.execOptions = options?.execOptions || {};
    this.processes = [];
    if (
      options.setPath &amp;&amp;
      process.env.PATH &amp;&amp;
      !process.env.PATH.includes(getAndroidToolBaseDir())
    )
      process.env.PATH = `${getAndroidToolBaseDir()}:${process.env.PATH}`;
  }

  /**
   * Terminate all child processes with extreme prejudice.
   */
  kill() {
    this.processes.forEach(child => child.kill()); // HE EVEN KILLED THE YOUNGLINGS
  }

  /**
   * Execute a command. Used for short operations and operations that do not require real-time data access.
   * @param  {...any} args tool arguments
   * @private
   * @returns {CancelablePromise&lt;String>} stdout
   */
  exec(...args) {
    const _this = this;
    return new CancelablePromise((resolve, reject, onCancel) => {
      const cp = child_process.execFile(
        _this.executable,
        [..._this.extra, ...args],
        _this.execOptions,
        (error, stdout, stderr) => {
          _this.emit(
            "exec",
            removeFalsy({
              cmd: [_this.tool, ..._this.extra, ...args],
              error: error
                ? {
                    message: error?.message
                      ?.replace(new RegExp(this.executable, "g"), this.tool)
                      .trim(),
                    code: error?.code,
                    signal: error?.signal,
                    killed: error?.killed
                  }
                : null,
              stdout: stdout?.trim(),
              stderr: stderr?.trim()
            })
          );
          if (error) {
            reject(new Error(_this.handleError(error, stdout, stderr)));
          } else {
            resolve(stdout?.trim() || stderr?.trim());
            this.processes.splice(this.processes.indexOf(cp), 1);
          }
        }
      );

      this.processes.push(cp);

      onCancel(() => {
        if (!cp.kill("SIGTERM")) {
          setTimeout(() => {
            cp.kill("SIGKILL");
          }, 25);
        }
      });
    });
  }

  /**
   * Spawn a child process. Used for long-running operations that require real-time data access.
   * @param  {...any} args tool arguments
   * @private
   * @returns {child_process.ChildProcess}
   */
  spawn(...args) {
    this.emit(
      "spawn:start",
      removeFalsy({ cmd: [this.tool, ...this.extra, ...args].flat() })
    );
    const cp = child_process.spawn(
      this.executable,
      [...this.extra, ...args].flat(),
      {
        env: {
          ...process.env,
          ADB_TRACE: "rwx"
        }
      }
    );
    this.processes.push(cp);
    cp.on("exit", (code, signal) => {
      this.processes.splice(this.processes.indexOf(cp), 1);
      this.emit(
        "spawn:exit",
        removeFalsy({
          cmd: [this.tool, ...this.extra, ...args].flat(),
          code,
          signal
        })
      );
    });
    cp.on("error", error =>
      this.emit(
        "spawn:error",
        removeFalsy({
          cmd: [this.tool, ...this.extra, ...args].flat(),
          error
        })
      )
    );
    return cp;
  }

  /**
   * Generate processable error messages from child_process.exec() callbacks
   * @param {child_process.ExecException} error error returned by child_process.exec()
   * @param {String} stdout stdandard output
   * @param {String} stderr standard error
   * @private
   * @returns {String} error message
   */
  handleError(error, stdout, stderr) {
    if (
      stderr?.includes("Killed") ||
      stderr?.includes("killed by remote request")
    ) {
      return "killed";
    } else {
      return JSON.stringify(
        removeFalsy({
          error: removeFalsy(error),
          stdout: stdout?.trim(),
          stderr: stderr?.trim()
        })
      ).replace(new RegExp(this.executable, "g"), this.tool);
    }
  }

  /**
   * Find out if a device can be seen
   * @virtual
   * @returns {CancelablePromise&lt;Boolean>} access?
   */
  hasAccess() {
    return CancelablePromise.reject(new Error("virtual"));
  }

  /**
   * Wait for a device
   * @returns {CancelablePromise}
   */
  wait() {
    var _this = this;
    return new CancelablePromise(function (resolve, reject, onCancel) {
      let timeout;
      function poll() {
        _this
          .hasAccess()
          .then(access => {
            if (access) {
              clearTimeout(timeout);
              resolve();
            } else {
              timeout = setTimeout(poll, 2000);
            }
          })
          .catch(error => {
            clearTimeout(timeout);
            reject(error);
          });
      }
      onCancel(() => {
        clearTimeout(timeout);
      });
      poll();
    });
  }
}
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="Adb.html">Adb</a></li><li><a href="DeviceTools.html">DeviceTools</a></li><li><a href="Fastboot.html">Fastboot</a></li><li><a href="Heimdall.html">Heimdall</a></li><li><a href="Tool.html">Tool</a></li></ul><h3>Global</h3><ul><li><a href="global.html#removeFalsy">removeFalsy</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 3.6.11</a> on Sun Nov 27 2022 14:05:10 GMT+0000 (Coordinated Universal Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
